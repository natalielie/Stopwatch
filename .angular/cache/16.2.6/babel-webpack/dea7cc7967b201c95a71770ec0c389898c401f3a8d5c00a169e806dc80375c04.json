{"ast":null,"code":"import { timer, BehaviorSubject, Subscription } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport * as i0 from \"@angular/core\";\nexport class TimeService {\n  constructor() {\n    this.initialTime = 0;\n    this.secondClick = false;\n    this.delay = 0;\n    this.timer$ = new BehaviorSubject(this.initialTime);\n    this.lastStopedTime = this.initialTime;\n    this.timerSubscription = new Subscription();\n    this.isRunning = false;\n  }\n  get stopWatch$() {\n    return this.timer$.pipe(map(seconds => this.secondsToStopWatch(seconds)));\n  }\n  startCount() {\n    if (this.isRunning) {\n      return;\n    }\n    this.timerSubscription = timer(0, 1000) // Timer, so that the first emit is instantly (interval waits until the period is over for the first emit)\n    .pipe(map(value => value + this.lastStopedTime)).subscribe(this.timer$); // each emit of the Observable will result in a emit of the BehaviorSubject timer$\n    this.isRunning = true;\n  }\n  stopTimer() {\n    this.lastStopedTime = this.timer$.value;\n    this.timerSubscription.unsubscribe();\n    this.isRunning = false;\n  }\n  resetTimer() {\n    this.timerSubscription.unsubscribe();\n    this.lastStopedTime = this.initialTime;\n    this.timer$.next(this.initialTime);\n    this.isRunning = false;\n  }\n  waitCount() {\n    let currentTime = Date.now();\n    if (!this.secondClick) {\n      this.secondClick = true;\n      this.delay = currentTime;\n      return;\n    }\n    if (currentTime - this.delay <= 300) {\n      this.lastStopedTime = this.timer$.value;\n      this.timerSubscription.unsubscribe();\n      this.isRunning = false;\n    }\n    this.secondClick = false;\n  }\n  secondsToStopWatch(seconds) {\n    let rest = seconds;\n    const hours = Math.floor(seconds / 3600);\n    rest = seconds % 3600;\n    const minutes = Math.floor(rest / 60);\n    rest = seconds % 60;\n    return {\n      hours: this.convertToNumberString(hours),\n      minutes: this.convertToNumberString(minutes),\n      seconds: this.convertToNumberString(seconds)\n    };\n  }\n  convertToNumberString(value) {\n    return `${value < 10 ? \"0\" + value : value}`;\n  }\n  static #_ = this.ɵfac = function TimeService_Factory(t) {\n    return new (t || TimeService)();\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: TimeService,\n    factory: TimeService.ɵfac,\n    providedIn: \"root\"\n  });\n}","map":{"version":3,"names":["timer","BehaviorSubject","Subscription","map","TimeService","constructor","initialTime","secondClick","delay","timer$","lastStopedTime","timerSubscription","isRunning","stopWatch$","pipe","seconds","secondsToStopWatch","startCount","value","subscribe","stopTimer","unsubscribe","resetTimer","next","waitCount","currentTime","Date","now","rest","hours","Math","floor","minutes","convertToNumberString","_","_2","factory","ɵfac","providedIn"],"sources":["D:\\Internship\\Task1_stopwatch\\Stopwatch\\src\\app\\timer.service.ts"],"sourcesContent":["import { Injectable } from \"@angular/core\";\r\nimport {\r\n  Observable,\r\n  timer,\r\n  BehaviorSubject,\r\n  Subscription\r\n} from \"rxjs\";\r\n\r\nimport { map, tap } from \"rxjs/operators\";\r\nimport { StopWatch } from \"./stop-watch.interface\";\r\n\r\n@Injectable({\r\n  providedIn: \"root\"\r\n})\r\nexport class TimeService {\r\n  private readonly initialTime = 0;\r\n  private secondClick = false;\r\n  private delay = 0;\r\n\r\n\r\n\r\n  private timer$: BehaviorSubject<number> = new BehaviorSubject(\r\n    this.initialTime\r\n  );\r\n  private lastStopedTime: number = this.initialTime;\r\n  private timerSubscription: Subscription = new Subscription();\r\n  private isRunning: boolean = false;\r\n\r\n  constructor() {}\r\n\r\n  public get stopWatch$(): Observable<StopWatch> {\r\n    return this.timer$.pipe(\r\n      map((seconds: number): StopWatch => this.secondsToStopWatch(seconds))\r\n    );\r\n  }\r\n\r\n  startCount(): void {\r\n    if (this.isRunning) {\r\n      return;\r\n    }\r\n    this.timerSubscription = timer(0, 1000) // Timer, so that the first emit is instantly (interval waits until the period is over for the first emit)\r\n      .pipe(map((value: number): number => value + this.lastStopedTime))\r\n      .subscribe(this.timer$); // each emit of the Observable will result in a emit of the BehaviorSubject timer$\r\n    this.isRunning = true;\r\n  }\r\n\r\n  stopTimer(): void {\r\n    this.lastStopedTime = this.timer$.value;\r\n    this.timerSubscription.unsubscribe();\r\n    this.isRunning = false;\r\n  }\r\n\r\n  resetTimer(): void {\r\n    this.timerSubscription.unsubscribe();\r\n    this.lastStopedTime = this.initialTime;\r\n    this.timer$.next(this.initialTime);\r\n    this.isRunning = false;\r\n  }\r\n\r\n  waitCount(): void {\r\n    let currentTime = Date.now()\r\n    if(!this.secondClick){\r\n      this.secondClick = true\r\n      this.delay = currentTime\r\n      return\r\n    }\r\n    if(currentTime - this.delay <= 300){\r\n      this.lastStopedTime = this.timer$.value;\r\n      this.timerSubscription.unsubscribe();\r\n      this.isRunning = false;\r\n    }\r\n    this.secondClick = false\r\n  }\r\n\r\n  private secondsToStopWatch(seconds: number): StopWatch {\r\n    let rest = seconds;\r\n    const hours = Math.floor(seconds / 3600);\r\n    rest = seconds % 3600;\r\n    const minutes = Math.floor(rest / 60);\r\n    rest = seconds % 60;\r\n\r\n    return {\r\n      hours: this.convertToNumberString(hours),\r\n      minutes: this.convertToNumberString(minutes),\r\n      seconds: this.convertToNumberString(seconds)\r\n    };\r\n  }\r\n\r\n  private convertToNumberString(value: number): string {\r\n    return `${value < 10 ? \"0\" + value : value}`;\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}